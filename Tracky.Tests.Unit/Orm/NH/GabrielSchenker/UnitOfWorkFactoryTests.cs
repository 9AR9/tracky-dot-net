using System;
using NHibernate;
using NHibernate.Impl;
using NUnit.Framework;
using Tracky.Orm.NH.GabrielSchenker;

namespace Tracky.Tests.Unit.Orm.NH.GabrielSchenker
{
    [TestFixture]
    class UnitOfWorkFactoryTests
    {
        private IUnitOfWorkFactory _unitOfWorkFactory;

        [SetUp]
        public void SetUpContext()
        {
            // The default constructor of UnitOfWorkFactory class is internal, which keeps the construction
            // of a new factory instance internal to the assembly implementing the Unit of Work pattern.
            // Thus, the Activator technique is used from this test assembly to create an instance.
            _unitOfWorkFactory = (IUnitOfWorkFactory)Activator.CreateInstance(typeof(UnitOfWorkFactory), true);
        }

        [Test]
        public void CanCreateUnitOfWork()
        {
            IUnitOfWorkImplementor implementor = _unitOfWorkFactory.Create();

            Assert.That(implementor, Is.Not.Null);
            Assert.That(_unitOfWorkFactory.CurrentSession, Is.Not.Null);
            Assert.That(_unitOfWorkFactory.CurrentSession.FlushMode, Is.EqualTo(FlushMode.Commit));
        }

        // THIS TEST WORKS! It reads the hibernate.cfg.xml file in from the copy to the Debug folder at
        // run time and verifies all of the properties. The only problem, demonstrated in the other tests,
        // seems to be that it's not finding the database correctly. It's looking to find it here in the
        // test project, but no no no it's not there, yo. It lives in the primary web project where the
        // EF implementation is that created it, at Tracky/App_Data. But even when these tests are copied
        // over to that main project, and the path to the DB appears to be correct, an error still tells
        // us that it cannot be openend. So...how to point NHibernate to a DB created via EF? That is
        // still a mystery that needs to be solved.
        // ----
        // Upon futher reading of my own implementation of NH against the LocalDB database generated by
        // EF in the main project, it seems all I needed to do was change the NHibernate connection
        // string to use Initial Catalog=Library Context, instead of the whole AttachDbFilename phrase.
        // The tests now seem to connect fine to the database, and we can move forward.
        [Test]
        public void CanConfigureNHibernate()
        {
            var configuration = _unitOfWorkFactory.Configuration;
            
            Assert.That(configuration, Is.Not.Null);
            Assert.AreEqual("NHibernate.Connection.DriverConnectionProvider",
                    configuration.Properties["connection.provider"]);
            Assert.AreEqual("NHibernate.Dialect.MsSql2012Dialect",
                            configuration.Properties["dialect"]);
            Assert.AreEqual("NHibernate.Driver.SqlClientDriver",
                            configuration.Properties["connection.driver_class"]);
            Assert.AreEqual("Data Source=(localdb)\\MSSQLLocalDB; Integrated Security=True; MultipleActiveResultSets=True; Initial Catalog=LibraryContext",
                            configuration.Properties["connection.connection_string"]);
        }

        [Test]
        public void CanCreateAndAccessSessionFactory()
        {
            var sessionFactory = _unitOfWorkFactory.SessionFactory;
            SessionFactoryImpl sessionFactoryImplementation = (SessionFactoryImpl) sessionFactory;

            Assert.That(sessionFactory, Is.Not.Null);
            Assert.That(sessionFactory, Is.TypeOf(typeof(SessionFactoryImpl)));
            Assert.That(sessionFactoryImplementation.Dialect.ToString(), Is.EqualTo("NHibernate.Dialect.MsSql2012Dialect"));
        }

        [Test]
        public void ShouldThrowErrorIfAccessingCurrentSessionWhenNoSessionHasBeenOpened()
        {
            var isException = false;

            try
            {
                var session = _unitOfWorkFactory.CurrentSession;
            }
            catch (InvalidOperationException ex)
            {
                isException = true;
            }

            Assert.That(isException, Is.True);
        }

        [TearDown]
        public void TearDownContext()
        {
            _unitOfWorkFactory.CurrentSession = null;
        }

    }
}
